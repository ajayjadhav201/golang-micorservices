package common

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	InvalidReqBody = "Invalid request body."
)

// xss cross site scripting
// csrf cross site request forgery

// to avoid csrf attacks
// 1. Same Site Cookie Attribute							Done
// 2. Anti csrf_tokens										x
// 3. Referer and Origin Header Validation					x
// 4. Double Submit Cookie Pattern							x
// 5. CORS (Cross-Origin Resource Sharing) Configuration	x
// 6. Secure and HttpOnly Cookie Attributes					Done

/*
2. Anti-CSRF Tokens
Anti-CSRF tokens are unique tokens that are generated by the server and included in forms or requests. These tokens must be validated by the server to ensure the request is legitimate.

Implementation Steps:

Generate Token: Generate a random token when rendering forms.
Include Token: Include the token in forms or as a custom header in AJAX requests.
Validate Token: Validate the token on the server side.

Anti-CSRF Tokens for Mobile Applications
	Step:	Generate CSRF Token on the Server
	Step:	Include CSRF Token in API Responses
	Step:	Store CSRF Token Securely on the Client
	Step:	Include CSRF Token in API Requests
	Step:	Validate CSRF Token on the Server
*/

func Cookie(Key string, Value string) *http.Cookie {
	return &http.Cookie{
		Name:     Key,
		Value:    Value,
		HttpOnly: true, //prevent javascript access
		Secure:   true, //if true these cookies only sent over https
		Path:     "/",
		SameSite: http.SameSiteStrictMode, //to avoid csrf attacks
	}
}
func SetCookie(w http.ResponseWriter, Key string, Value string) *http.Cookie {
	return &http.Cookie{
		Name:     Key,
		Value:    Value,
		HttpOnly: true,
		Secure:   true,
		Path:     "/",
		SameSite: http.SameSiteStrictMode,
	}
}

func GetCookie(r *http.Request, Key string, DefaultValue string) string {
	c, e := r.Cookie(Key)
	if e != nil {
		return DefaultValue
	}
	return c.Value
}

func ValidateRefererAndOrigin(w http.ResponseWriter, r *http.Request) {
	referer := r.Header.Get("Referer")
	origin := r.Header.Get("Origin")

	expectedDomain := "https://example.com"

	if referer != "" && !strings.HasPrefix(referer, expectedDomain) {
		http.Error(w, "Invalid referer", http.StatusForbidden)
		return
	}

	if origin != "" && origin != expectedDomain {
		http.Error(w, "Invalid origin", http.StatusForbidden)
		return
	}

	// fmt.Fprintln(w, "Referer and Origin validated successfully")
}

func WriteError(c *gin.Context, status int, message string) {
	WriteJSON(c, status, map[string]string{"error": message})
}

func WriteInternalServerError(c *gin.Context) {
	WriteError(c, http.StatusInternalServerError, "Internal server error")
}

func WriteServerNotAvailableError(c *gin.Context) {
	WriteError(c, http.StatusInternalServerError, "Server not available.")
}

func WriteGrpcError(c *gin.Context, err error) {
	if err == nil {
		return
	}
	// Check if the error is a gRPC status
	st, _ := status.FromError(err)
	//
	switch st.Code() {
	case codes.Unavailable:
		WriteServerNotAvailableError(c)
	case codes.Unknown:
		WriteError(c, http.StatusBadRequest, st.Message())
	default:
		WriteError(c, http.StatusBadRequest, err.Error())
	}

	//
}

func WriteRequestBodyError(c *gin.Context, err error) {
	//create custom error messages here
	if strings.Contains(err.Error(), "Key") {
		newerr := ""
		for i, err := range err.(validator.ValidationErrors) {
			if i != 0 {
				newerr = Sprintf("%s, ", newerr)
			}
			fieldName := err.Field()
			fieldTag := err.Tag()

			Println("ajaj fields are name: ", fieldName, "tag : ", fieldTag)
			switch fieldTag {
			case "email":
				Println("ajaj showing email error ", newerr)
				newerr = Sprintf("%s%s", newerr, "email is not valid")
			case "mobile":
				Println("ajaj showing mobile number error ", newerr)
				newerr = Sprintf("%s%s", newerr, "mobile number is not valid")
			case "required":
				newerr = Sprintf("%s%s is required", newerr, fieldName)
			case "gte":
				newerr = Sprintf("%s%s is too short", newerr, fieldName)
			}

		}
		if len(newerr) < 1 {
			WriteError(c, http.StatusBadRequest, InvalidReqBody)
		} else {
			WriteError(c, http.StatusBadRequest, newerr)
		}
		// return errors.New(newerr)
	} else if strings.Contains(err.Error(), "EOF") {
		WriteError(c, http.StatusBadRequest, InvalidReqBody)
	} else {
		WriteError(c, http.StatusBadRequest, InvalidReqBody)
	}
}
